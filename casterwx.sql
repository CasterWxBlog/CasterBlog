-- MySQL dump 10.13  Distrib 5.7.20, for Win64 (x86_64)
--
-- Host: localhost    Database: casterwx
-- ------------------------------------------------------
-- Server version	5.7.20-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `t_blog`
--

DROP TABLE IF EXISTS `t_blog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_blog` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) DEFAULT NULL,
  `author` varchar(255) DEFAULT NULL,
  `localurl` varchar(255) DEFAULT NULL,
  `imgurl` varchar(255) DEFAULT NULL,
  `time` varchar(255) DEFAULT NULL,
  `review` int(11) DEFAULT NULL,
  `memage` int(11) DEFAULT NULL,
  `code` varchar(5000) DEFAULT NULL,
  `local` varchar(255) DEFAULT NULL,
  `data` text,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_blog`
--

LOCK TABLES `t_blog` WRITE;
/*!40000 ALTER TABLE `t_blog` DISABLE KEYS */;
INSERT INTO `t_blog` VALUES (1,'Antz操作系统','AntzUhl','/list/detail1.jsp','../images/cover/851637d2e492bbe6b7222fb5d91919f5.png','2018-11-3',124,14,'摘要: 我已经规范了系统代码风格，类似于按照linux分包，把各部分功能区分开了 \"Antz系统更新地址\" \"Linux内核源码分析地址\" \"Github项目地址\" 在之前的任务中，我们已经通过直接操作显卡驱动完成了简单的图形化。 需要了解之前的部分： 直接操作显卡请参考day03 简单图形化的实现请参考d','操作系统,Antz','# 自制操作系统Antz\n> 我已经规范了系统代码风格，类似于按照linux分包，把各部分功能区分开了\n\n### 显示图片\n![run](https://github.com/CasterWx/AntzOS/blob/master/screen/a.gif?raw=true)\n\n### 动态\n![run](https://github.com/CasterWx/AntzOS/blob/master/screen/execute.gif?raw=true)\n![antz_run](https://github.com/CasterWx/AntzOS/blob/master/screen/antz_gif.gif?raw=true)\n\n### [Antz系统更新地址](https://www.cnblogs.com/LexMoon/category/1262287.html)\n\n### [Linux内核源码分析地址](https://www.cnblogs.com/LexMoon/category/1267413.html)\n\n### [Github项目地址](https://github.com/CasterWx/AntzOS)\n\n### 在之前的工作中，AntzOS已经从单调的界面，变得逐渐拥有自己的功能了。\n\n### 真机运行情况 ：\n![os1](https://www.cnblogs.com/images/cnblogs_com/LexMoon/1246510/o_qq_pic_merged_1539834568688.jpg)\n\n![os2](https://www.cnblogs.com/images/cnblogs_com/LexMoon/1246510/o_antzos4.jpg)\n\n![os3](https://www.cnblogs.com/images/cnblogs_com/LexMoon/1246510/o_qq_pic_merged_1539834611072.jpg)\n\n### 这个系统在我最初的目的中就是实现一个半图形半终端的轻巧OS。\n\n### 完成了当前的工作后，Antz接下来需要实现的则是关于任务调度相关的。\n\n### 目前实现的是在Terminal中对命令的响应，还有一个简易的vim，可以用于右边界面的文本编辑。\n\n### 对于按键中断，对全键盘的响应改良之后不会出现之前说的bug，但是在shift按下时的按键模式却是有很大问题，虽然我已经想到了解决方案，不外乎给shift的按下一个flag，弹起一个flag，但这部分感觉现在实现与否都是不怎么重要，所以就先忽略这里了。\n\n### 最近同时也在读Linux内核源码。发现其中的注释也是很有意思，甚至Linus自己写的，他也不知道这部分为什么这样写，不断尝试之后发现可以实现，他就这样用了。\n\n### 仔细看看关于按键响应命令的实现，现在只能说很懵，又臭又长，估计随便改改我就会不知道怎么继续下一步了。（不过好在我每添加一个功能都会把整个项目备份一份）\n\n```\nvoid key(Binfo binfo,char s[40]){\n	if((strcmp(s,\"1C\")==0)){  // enter\n			if(x_move!=0){\n				// 右边\n				write_x = 58 ;\n				write_y += 19 ;\n			}else {\n				// 左边\n				action_command(binfo);\n				write_x = 58 ;\n				write_y += 19 ;\n				if (x_move==0)\n					printasc(binfo->vram, binfo->scrnx, 4, write_y, COL8_FFFFFF, \"AntzOS>\");\n			}\n	}else if((strcmp(s,\"0F\")==0)){\n		// 关于tab 0F 8F\n		printasc(binfo->vram, binfo->scrnx, x_move+write_x, write_y, COL8_FFFFFF, \" \");\n		write_x += 8 ;\n		border(binfo);\n		printasc(binfo->vram, binfo->scrnx, x_move+write_x, write_y, COL8_FFFFFF, \" \");\n		write_x += 8 ;\n		border(binfo);\n		printasc(binfo->vram, binfo->scrnx, x_move+write_x, write_y, COL8_FFFFFF, \" \");\n		write_x += 8 ;\n		border(binfo);\n	}else if((strcmp(s,\"3B\")==0)){  //关于F1的响应中断\n			sprintf(command,\"%s\",\"\");\n			// flag = 0\n			x_move = 0 ;\n			new_pe(binfo);\n			printasc(binfo->vram, binfo->scrnx, 4, write_y, COL8_FFFFFF, \"AntzOS>\");\n	}else if(strcmp(s,\"0E\")==0){\n			// 回退\n			int len = strlen(command);\n			command[len - 1] = \'\\0\';\n			write_x -= 8 ;\n			flash(binfo->vram, binfo->scrnx , COL8_000000,  x_move + write_x,     write_y,     x_move+write_x+19, write_y+19);\n			if(x_move!=0){\n   				// 正在右边界\n					if(write_x<=60) {\n						write_x = 202 ;\n						write_y -= 19 ;\n					}\n			}else if(x_move==0){\n					// 正在左边界\n					if(write_x<=4) {\n						write_x = 146 ;\n						write_y -= 19 ;\n					}\n			}\n\n	}else {\n			char *in = replace_char(s) ;\n			if(strcmp(in,\"\")==0){\n\n			}else {\n				printasc(binfo->vram, binfo->scrnx,  x_move + write_x,  write_y, COL8_FFFFFF, in);\n				add_command(in);\n				write_x += 8 ;\n			}\n			// 添加响应区\n			//清除\n			//打印字符 Only use debug\n	}\n	border(binfo);\n}\n// 边界处理\nvoid border(struct BOOTINFO *binfo){\n	if (x_move==0){\n		// 左边\n		if(write_x>148){\n			write_x = 4 ;\n			write_y += 19 ;\n		}\n		if(write_y>180){\n	 		new_pe(binfo);\n			printasc(binfo->vram, binfo->scrnx, 4, write_y, COL8_FFFFFF, \"AntzOS>\");\n		}\n	}else if(x_move!=0){\n		// vim模式\n		if(write_x>310-x_move){\n			write_x = 58 ;\n			write_y += 19 ;\n		}\n		if(write_y>180){\n			write_y = 15 ;\n			write_x = 58 ;\n			flash(binfo->vram,binfo->scrnx,COL8_000000, 160,0,320-3,260-3);\n			printasc(binfo->vram,binfo->scrnx,162,2,COL8_00FF00,\"Vim :\");\n		}\n	}\n}\n```\n\n\n### 目前的项目目录，请忽略掉md文件，这个镜像文件可以直接使用工具写入u盘启动，或者在虚拟机打开。thun.c是今天(2018年10月18日)新增的，目的是为了抽离其他c文件中的工具化函数，不然以后只是一个源码文件都会让人头疼。\n\n```\n▒▒  antz.img\n▒▒  Makefile\n▒▒  README.md\n▒▒\n▒▒▒▒asmfunc\n▒▒      naskfunc.nas\n▒▒\n▒▒▒▒assic\n▒▒      char.set\n▒▒\n▒▒▒▒boot\n▒▒      asmhead.asm\n▒▒      mbr.asm\n▒▒\n▒▒▒▒include\n▒▒      errno.h\n▒▒      float.h\n▒▒      limits.h\n▒▒      math.h\n▒▒      stdio.h\n▒▒      string.h\n▒▒      todo.h\n▒▒\n▒▒▒▒interrupt\n▒▒      int.c\n▒▒\n▒▒▒▒io\n▒▒      fifo.c\n▒▒\n▒▒▒▒lgdt\n▒▒      set_lgdt.c\n▒▒\n▒▒▒▒log\n▒▒      build.log\n▒▒      delete.log\n▒▒\n▒▒▒▒main\n▒▒      bootpack.c\n▒▒      README..md\n▒▒      shell_1.md\n▒▒      shell_2.md\n▒▒\n▒▒▒▒thun\n▒▒      thun.c\n▒▒\n▒▒▒▒windows\n        graphic.c\n\n```\n\n### Makefile非常关键，如果没有这个，怕是我只是编译链接就得花费很长时间，而且中间估计会错误频出。\n> Antz_kernel = main/bootpack.obj asmfunc/naskfunc.obj assic/char.set windows/graphic.obj lgdt/set_lgdt.obj interrupt/int.obj io/fifo.obj thun/thun.obj\n\n### 之后的添加c文件，只需要在这里预先确定路径，然后将需要实现的函数声明在include/todo.h中即可。显卡虽然实现了函数可以直接操作，但是分辨率太低，导致界面极不美观，网卡驱动暂时没有想过要写，如果要实现，恐怕得整个antz都可以让用户使用的情况下才具备条件。\n\n### [AntzOs](https://github.com/CasterWx/AntzOS)需要更多优秀的开发者来实现，无论你是正在学习操作系统课程还是其他方面，我相信AntzOs都可以帮助你更加的深入了解计算机操作系统底层的实现。\n'),(2,'基于MFC的指纹识别系统','CasterWx','/list/detail2.jsp','../images/cover/201703181909057125.jpg','2018-11-18',2425,54,'在第12步特征入库中，会对当前指纹的mdl数据与databases中所有的mdl进行对比,然后返回识别结果.','C++,MFC','# MFC-FingerPrint\r\n基于MFC开发的指纹识别系统.\r\n\r\n---------\r\n##### 效果图如下:\r\n\r\n![1](https://github.com/CasterWx/MFC-FingerPrint/raw/master/img/1.png)\r\n\r\n\r\n在第12步特征入库中，会对当前指纹的mdl数据与databases中所有的mdl进行对比,然后返回识别结果.\r\n\r\n\r\n\r\n## 一.载入图像\r\n\r\n在点击之后,选择需要识别的图片. 图片路径为beginfilename.\r\n```c++\r\nvoid CFingerDlg::OnBnClickedOk1()\r\n{\r\n	CFileDialog    dlgFile(TRUE, NULL, NULL, OFN_HIDEREADONLY, _T(\"Describe Files (*.bmp)|*.bmp|All Files (*.*)|*.*||\"), NULL);\r\n\r\n	if (dlgFile.DoModal())\r\n	{\r\n		strFile = dlgFile.GetPathName();\r\n	}\r\n	char *info = \"\";\r\n\r\n	USES_CONVERSION;\r\n	char * beginfilename = T2A(strFile);\r\n	Step1_LoadBmpImage(beginfilename,info);\r\n\r\n	ShowImageInCtrl(m_picCtrl1, beginfilename);\r\n\r\n	// TODO: 在此添加控件通知处理程序代码\r\n}\r\n```\r\nStep1_LoadBmpImage中就是获取初始图片的RGB信息.\r\n```c++\r\nint Step1_LoadBmpImage(char *beginfilename,char* info) {\r\n	char *filename = beginfilename;\r\n	CopyFile(ToWideChar(filename), ToWideChar(STEP_TXT_1), false);\r\n\r\n	int iWidth, iHeight, iDepth;\r\n	int flag = ReadBMPImgFilePara(filename, iWidth, iHeight, iDepth);\r\n	if (flag != 0) {\r\n		//sprintf(info,\"图像加载失败\");\r\n		::MessageBox(NULL, _T(\"图像加载失败\"), _T(\"error\"), MB_OK);\r\n		return -1;\r\n	}\r\n	unsigned char *data = new unsigned char[iWidth*iHeight];\r\n	flag = ReadBMPImgFileData(filename, data);\r\n	if (flag != 0) {\r\n		//sprintf(info, \"图像数据读取失败\");\r\n		::MessageBox(NULL, _T(\"图像数据读取失败\"), _T(\"error\"), MB_OK);\r\n		delete[] data;\r\n		return -2;\r\n	}\r\n	flag = SaveDataToTextFile(STEP_TXT_1, data, iWidth, iHeight);\r\n	if (flag != 0) {\r\n		//sprintf(info,\"数据保存失败\");\r\n		::MessageBox(NULL, _T(\"数据保存失败\"), _T(\"error\"), MB_OK);\r\n		delete[] data;\r\n		return -3;\r\n	}\r\n	//sprintf(info, \"源图[%s],宽度[%d]，高度[%d]，深度[%d b]\",filename,iWidth,iHeight,iDepth);\r\n	delete[] data;\r\n	return 0;\r\n}\r\n```\r\n\r\n其中具体的Txt与BMP转换参考具体源代码.\r\n\r\n---------\r\n\r\n## 二.中值滤波\r\n中值滤波实现算法,ucImg由第一步得来.\r\n```c++\r\nint MidFilter(unsigned char *ucImg, unsigned char *ucDstImg, int iWidth, int iHeight) {\r\n	memset(ucDstImg, 0, iWidth*iHeight);\r\n	unsigned char *pUp, *pDown, *pImg;\r\n	unsigned char x[9];\r\n	for (int i = 1; i < iHeight - 1; i++) {\r\n		pUp = ucImg + (i - 1)*iWidth;\r\n		pImg = ucImg + i * iWidth;\r\n		pDown = ucImg + (i + 1)*iWidth;\r\n		int j;\r\n		for (j = 1; j < iWidth - 1; j++) {\r\n			pUp++;\r\n			pImg++;\r\n			pDown++;\r\n			x[0] = *(pUp - 1);\r\n			x[1] = *(pImg - 1);\r\n			x[2] = *(pDown - 1);\r\n			x[3] = *pUp;\r\n			x[4] = *pImg;\r\n			x[5] = *pDown;\r\n			x[6] = *(pUp + 1);\r\n			x[7] = *(pImg + 1);\r\n			x[8] = *(pDown + 1);\r\n\r\n			Sort(x, 9);\r\n			*(ucDstImg + i * iWidth + j) = x[4];\r\n		}\r\n	}\r\n	int j;\r\n	pDown = ucImg + iWidth;\r\n	for (j = 1; j < iWidth - 1; j++) {\r\n		x[0] = *(ucImg + j - 1);\r\n		x[1] = *(ucImg + j);\r\n		x[2] = *(ucImg + j + 1);\r\n		x[3] = *(pDown + j - 1);\r\n		x[4] = *(pDown + j);\r\n		x[5] = *(pDown + j + 1);\r\n		Sort(x, 6);\r\n		*(ucDstImg + j) = x[3];\r\n	}\r\n	pUp = ucImg + iWidth * (iHeight - 2);\r\n	pDown = ucImg + iWidth * (iHeight - 1);\r\n	for (j = 1; j < iWidth - 1; j++) {\r\n		x[0] = *(pDown + j - 1);\r\n		x[1] = *(pDown + j);\r\n		x[2] = *(pDown + j + 1);\r\n		x[3] = *(pUp + j - 1);\r\n		x[4] = *(pUp + j);\r\n		x[5] = *(pUp + j + 1);\r\n		Sort(x, 6);\r\n		*(ucDstImg + iWidth * (iHeight - 1) + j) = x[3];\r\n	}\r\n	x[0] = *(ucImg);\r\n	x[1] = *(ucImg + 1);\r\n	x[2] = *(ucImg + iWidth);\r\n	x[3] = *(ucImg + iWidth + 1);\r\n	Sort(x, 4);\r\n	*(ucDstImg) = x[2];\r\n\r\n	x[0] = *(ucImg + iWidth - 1);\r\n	x[1] = *(ucImg + iWidth - 2);\r\n	x[2] = *(ucImg + 2 * iWidth - 1);\r\n	x[3] = *(ucImg + 2 * iWidth - 2);\r\n\r\n	Sort(x, 4);\r\n	*(ucDstImg + iWidth - 1) = x[2];\r\n\r\n	x[0] = *(ucImg + iWidth * (iHeight - 1));\r\n	x[1] = *(ucImg + iWidth * (iHeight - 2));\r\n	x[2] = *(ucImg + iWidth * (iHeight - 1) + 1);\r\n	x[3] = *(ucImg + iWidth * (iHeight - 2) + 1);\r\n	Sort(x, 4);\r\n	*(ucDstImg + (iHeight - 1)*iWidth) = x[2];\r\n	x[0] = *(ucImg + iWidth * (iHeight - 0) - 1);\r\n	x[1] = *(ucImg + iWidth * (iHeight - 1) - 1);\r\n	x[2] = *(ucImg + iWidth * (iHeight - 0) - 2);\r\n	x[3] = *(ucImg + iWidth * (iHeight - 1) - 2);\r\n	Sort(x, 4);\r\n\r\n	*(ucDstImg + (iHeight - 0)*iWidth - 1) = x[2];\r\n\r\n	return 0;\r\n}\r\n```\r\n\r\n![2](https://github.com/CasterWx/MFC-FingerPrint/raw/master/img/step2_MidFilter.bmp)\r\n\r\n --------\r\n## 三.均值化\r\n```c++\r\nint HistoNormalize(unsigned char* ucImg,unsigned char* ucNormImg, int iWidth,int iHeight) {\r\n	unsigned int Histogram[256];\r\n\r\n	memset(Histogram, 0, 256 * sizeof(int));\r\n	for (int i = 0; i < iHeight; i++) {\r\n		for (int j = 0; j < iWidth; j++) {\r\n			Histogram[ucImg[i*iWidth + j]]++;\r\n		}\r\n	}\r\n	double dMean = 0;\r\n	for (int i = 1; i < 255; i++) {\r\n		dMean += i * Histogram[i];\r\n	}\r\n	dMean = int(dMean/(iWidth*iHeight));\r\n	double dSigma = 0;\r\n	for (int i = 0; i < 255; i++) {\r\n		dSigma += Histogram[i] * (i - dMean)*(i-dMean);\r\n	}\r\n	dSigma /= (iWidth*iHeight);\r\n	dSigma = sqrt(dSigma);\r\n\r\n	double dMean0 = 128, dSigma0 = 128;\r\n	double dCoeff = dSigma0 / dSigma;\r\n	for (int i = 0; i < iHeight; i++) {\r\n		for(int j=0;j<iWidth;j++){\r\n			double dVal = ucImg[i*iWidth + j];\r\n			dVal = dMean0 + dCoeff * (dVal-dMean0);\r\n			if (dVal < 0) {\r\n				dVal = 0;\r\n			}\r\n			else if (dVal > 255) {\r\n				dVal = 255;\r\n			}\r\n			ucNormImg[i*iWidth + j] = (unsigned char)dVal;\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n```\r\n![3](https://github.com/CasterWx/MFC-FingerPrint/raw/master/img/step3_Normalize.bmp)\r\n\r\n--------\r\n## 四.方向计算\r\n```c++\r\nint ImgDirection(unsigned char* ucImg,float* fDirc,int iWidth,int iHeight) {\r\n	const int SEMISIZ = 7;\r\n	int dx[SEMISIZ * 2 + 1][SEMISIZ * 2 + 1];\r\n	int dy[SEMISIZ * 2 + 1][SEMISIZ * 2 + 1];\r\n	float fx, fy;\r\n	memset(fDirc, 0, iWidth*iHeight * sizeof(float));\r\n	for (int y = SEMISIZ + 1; y < iHeight - SEMISIZ - 1; y++) {\r\n		for (int x = SEMISIZ + 1; x < iWidth - SEMISIZ - 1; x++) {\r\n			for (int j = 0; j < SEMISIZ * 2 + 1; j++) {\r\n				for (int i = 0; i < SEMISIZ * 2 + 1; i++) {\r\n					int index1 = (y + j - SEMISIZ)*iWidth + x + i - SEMISIZ;\r\n					int index2 = (y + j - SEMISIZ)*iWidth + x + i - SEMISIZ - 1;\r\n					int index3 = (y + j - SEMISIZ - 1)*iWidth + x + i - SEMISIZ;\r\n					dx[i][j] = int(ucImg[index1] - ucImg[index2]);\r\n					dy[i][j] = int(ucImg[index1] - ucImg[index3]);\r\n				}\r\n			}\r\n			fx = 0.0;\r\n			fy = 0.0;\r\n			for (int j = 0; j < SEMISIZ * 2 + 1; j++) {\r\n				for (int i = 0; i < SEMISIZ * 2 + 1; i++) {\r\n					fx += 2 * dx[i][j] * dy[i][j];\r\n					fy += (dx[i][j] * dx[i][j] - dy[i][j] * dy[i][j]);\r\n				}\r\n			}\r\n			fDirc[y*iWidth + x] = atan2(fx,fy);\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n```\r\n![4](https://github.com/CasterWx/MFC-FingerPrint/raw/master/img/step4_Direction.bmp)\r\n\r\n--------\r\n## 五.频率计算\r\n```c++\r\nint DircLowPass(float *fDirc,float* fFitDirc,int iWidth,int iHeight) {\r\n	const int DIR_FILTER_SIZE = 2;\r\n	int blocksize = 2 * DIR_FILTER_SIZE + 1;\r\n	int imgsize = iWidth * iHeight;\r\n	float *filter = new float[blocksize*blocksize];\r\n	float *phix = new float[imgsize];\r\n	float *phiy = new float[imgsize];\r\n	float *phi2x = new float[imgsize];\r\n	float *phi2y = new float[imgsize];\r\n	memset(fFitDirc,0,sizeof(float)*iWidth*iHeight);\r\n	float tempSum = 0.0;\r\n	for (int y = 0; y < blocksize; y++) {\r\n		for (int x = 0; x < blocksize; x++) {\r\n			filter[y*blocksize + x] = (float)(blocksize - (abs(DIR_FILTER_SIZE - x) + abs(DIR_FILTER_SIZE - y)));\r\n			tempSum += filter[y*blocksize + x];\r\n		}\r\n	}\r\n	for (int y = 0; y < blocksize; y++) {\r\n		for (int x = 0; x < blocksize; x++) {\r\n			filter[y*blocksize + x] /= tempSum;\r\n		}\r\n	}\r\n	for(int y=0;y<iHeight;y++){\r\n		for (int x = 0; x < iWidth; x++) {\r\n			phix[y*iWidth + x] = cos(fDirc[y*iWidth + x]);\r\n			phiy[y*iWidth + x] = sin(fDirc[y*iWidth + x]);\r\n		}\r\n	}\r\n	memset(phi2x, 0, sizeof(float)*imgsize);\r\n	memset(phi2y, 0, sizeof(float)*imgsize);\r\n	float nx, ny;\r\n	int val;\r\n	for (int y = 0; y < iHeight - blocksize; y++) {\r\n		for (int x = 0; x < iWidth - blocksize; x++) {\r\n			nx = 0.0;\r\n			ny = 0.0;\r\n			for (int j = 0; j < blocksize; j++) {\r\n				for (int i = 0; i < blocksize; i++) {\r\n					val = (x + i) + (j + y)*iWidth;\r\n					nx += filter[j*blocksize + i] * phix[val];\r\n					ny += filter[j*blocksize + i] * phiy[val];\r\n				}\r\n			}\r\n			val = x + y * iWidth;\r\n			phi2x[val] = nx;\r\n			phi2y[val] = ny;\r\n		}\r\n	}\r\n\r\n	for (int y = 0; y < iHeight - blocksize; y++) {\r\n		for (int x = 0; x < iWidth - blocksize; x++) {\r\n			val = x + y * iWidth;\r\n			fFitDirc[val] = atan2(phi2y[val],phi2x[val])*0.5;\r\n		}\r\n	}\r\n	delete[] phi2y;\r\n	delete[] phi2x;\r\n	delete[] phiy;\r\n	delete[] phix;\r\n\r\n	return 0;\r\n}\r\n```\r\n![5](https://github.com/CasterWx/MFC-FingerPrint/raw/master/img/step5_Frequency.bmp)\r\n\r\n--------\r\n\r\n## 六.掩码计算\r\n```c++\r\nint GetMask(unsigned char* ucImg,float *fDirection,float *fFrequency,unsigned char *ucMask,int iWidth,int iHeight) {\r\n	float freqMin = 1.0 / 25.0;\r\n	float freqMax = 1.0 / 3.0;\r\n	int x, y, k;\r\n	int pos, posout;\r\n	memset(ucMask,0,iWidth*iHeight);\r\n	for (y = 0; y < iHeight; y++) {\r\n		for (x = 0; x < iWidth; x++) {\r\n			pos = x + y * iWidth;\r\n			posout = x + y * iWidth;\r\n			ucMask[posout] = 0;\r\n			if (fFrequency[pos] >= freqMin && fFrequency[pos] <= freqMax) {\r\n				ucMask[posout] = 255;\r\n			}\r\n		}\r\n	}\r\n	for (k = 0; k < 4; k++) {\r\n		for (y = 1; y < iHeight - 1; y++) {\r\n			for (x = 1; x < iWidth - 1; x++) {\r\n				if (ucMask[x + y * iWidth] == 0xFF) {\r\n					ucMask[x - 1 + y * iWidth] |= 0x80;\r\n					ucMask[x + 1 + y * iWidth] |= 0x80;\r\n					ucMask[x + (y-1) * iWidth] |= 0x80;\r\n					ucMask[x + (y+1) * iWidth] |= 0x80;\r\n				}\r\n			}\r\n		}\r\n		for (y = 1; y < iHeight - 1; y++) {\r\n			for (x = 1; x < iWidth - 1; x++) {\r\n				if (ucMask[x + y * iWidth]) {\r\n					ucMask[x + y * iWidth] = 0xFF;\r\n				}\r\n			}\r\n		}\r\n	}\r\n	for (k = 0; k < 12; k++) {\r\n		for (y = 1; y < iHeight - 1; y++) {\r\n			for (x = 1; x < iWidth - 1; x++) {\r\n				if (ucMask[x + y * iWidth] == 0x0) {\r\n					ucMask[x - 1 + y * iWidth] &= 0x80;\r\n					ucMask[x + 1 + y * iWidth] &= 0x80;\r\n					ucMask[x + (y - 1) * iWidth] &= 0x80;\r\n					ucMask[x + (y + 1) * iWidth] &= 0x80;\r\n				}\r\n			}\r\n		}\r\n		for (y = 1; y < iHeight - 1; y++) {\r\n			for (x = 1; x < iWidth - 1; x++) {\r\n				if (ucMask[x + y * iWidth] != 0xFF) {\r\n					ucMask[x + y * iWidth] = 0x0;\r\n				}\r\n			}\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n```\r\n![6](https://github.com/CasterWx/MFC-FingerPrint/raw/master/img/step6_Mask.bmp)\r\n\r\n--------\r\n## 七.Gabor增强\r\n```c++\r\nint GaborEnhance(unsigned char* ucImg, float* fDirection, float* fFrequency, unsigned char* ucMask, unsigned char* ucImgEnhanced, int iWidth, int iHeight) {\r\n	const float PI = 3.141592654;\r\n	int i, j, u, v;\r\n	int wg2 = 5;\r\n	float sum, f, g;\r\n	float x2, y2;\r\n	float dx2 = 1.0 / (4.0*4.0);\r\n	float dy2 = 1.0 / (4.0*4.0);\r\n	memset(ucImgEnhanced,0,iWidth*iHeight);\r\n	for (j = wg2; j < iHeight - wg2; j++) {\r\n		for (i = wg2; i < iWidth - wg2; i++) {\r\n			if (ucMask[i + j * iWidth] == 0) {\r\n				continue;\r\n			}\r\n			g = fDirection[i+j*iWidth];\r\n			f = fFrequency[i+j*iWidth];\r\n			g += PI / 2;\r\n			sum = 0.0;\r\n			for (v = -wg2; v <= wg2; v++) {\r\n				for (u = -wg2; u <= wg2; u++) {\r\n					x2 = -u * sin(g) + v * cos(g);\r\n					y2 = u * cos(g) + v * sin(g);\r\n					sum += exp(-0.5*(x2*x2*dx2 + y2 * y2*dy2))*cos(2 * PI*x2*f)*ucImg[(i - u) + (j - v)*iWidth];\r\n				}\r\n			}\r\n			if (sum > 255.0) {\r\n				sum = 255.0;\r\n			}\r\n			if (sum < 0.0) {\r\n				sum = 0.0;\r\n			}\r\n			ucImgEnhanced[i + j * iWidth] = (unsigned char)sum;\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n```\r\n![7](https://github.com/CasterWx/MFC-FingerPrint/raw/master/img/step7_GaborEnhance.bmp)\r\n\r\n--------\r\n## 八.二值化\r\n```c++\r\n\r\nint BinaryImg(unsigned char* ucImage,unsigned char* ucBinImage,int iWidth,int iHeight,unsigned char uThreshold) {\r\n	unsigned char *pStart = ucImage, *pEnd = ucImage + iWidth * iHeight;\r\n	unsigned char *pDest = ucBinImage;\r\n	while (pStart < pEnd) {\r\n		*pDest = *pStart > uThreshold ? 1 : 0;\r\n		pStart++;\r\n		pDest++;\r\n	}\r\n	return 0;\r\n}\r\n\r\nint BinaryToGray(unsigned char *ucBinImg,unsigned char *ucGrayImg,int iWidth,int iHeight) {\r\n	unsigned char *pStart = ucBinImg, *pEnd = ucBinImg + iWidth * iHeight;\r\n	unsigned char *pDest = ucGrayImg;\r\n\r\n	while (pStart<pEnd) {\r\n		*pDest = (*pStart) > 0 ? 255 : 0;\r\n		pStart++;\r\n		pDest++;\r\n	}\r\n	return 0;\r\n}\r\n```\r\n![8](https://github.com/CasterWx/MFC-FingerPrint/raw/master/img/step8_Binary.bmp)\r\n\r\n--------\r\n## 九.细化\r\n```c++\r\nint Thinning(unsigned char *ucBinedImg,unsigned char *ucThinnedImage,int iWidth,int iHeight,int iIterativeLimit) {\r\n	unsigned char x1, x2, x3, x4, x5, x6, x7, x8, xp;\r\n	unsigned char g1, g2, g3, g4;\r\n	unsigned char b1, b2, b3, b4;\r\n	unsigned char np1, np2, npm;\r\n	unsigned char *pUp, *pDown, *pImg;\r\n	int iDeletePoints = 0;\r\n\r\n	memcpy(ucThinnedImage,ucBinedImg,iWidth*iHeight);\r\n	for (int it = 0; it < iIterativeLimit; it++) {\r\n		iDeletePoints = 0;\r\n		for (int i = 1; i < iHeight - 1; i++) {\r\n			pUp = ucBinedImg + (i - 1)*iWidth;\r\n			pImg = ucBinedImg + i * iWidth;\r\n			pDown = ucBinedImg + (i + 1)*iWidth;\r\n			for (int j = 1; j < iWidth - 1; j++) {\r\n				pUp++;\r\n				pImg++;\r\n				pDown++;\r\n				if (!*pImg) {\r\n					continue;\r\n				}\r\n				x6 = *(pUp - 1);\r\n				x5 = *(pImg - 1);\r\n				x4 = *(pDown - 1);\r\n				x7 = *pUp;\r\n				xp = *pImg;\r\n				x3 = *pDown;\r\n				x8 = *(pUp + 1);\r\n				x1 = *(pImg+1);\r\n				x2 = *(pDown+1);\r\n\r\n\r\n				b1 = !x1 && (x2 == 1 || x3 == 1);\r\n				b2 = !x3 && (x4 == 1 || x5 == 1);\r\n				b3 = !x5 && (x6 == 1 || x7 == 1);\r\n				b4 = !x7 && (x8 == 1 || x1 == 1);\r\n\r\n				g1 = (b1 + b2 + b3 + b4) == 1;\r\n\r\n				np1 = x1 || x2;\r\n				np1 += x3 || x4;\r\n				np1 += x5 || x6;\r\n				np1 += x7 || x8;\r\n				np2  = x2 || x3;\r\n				np2 += x4 || x5;\r\n				np2 += x6 || x7;\r\n				np2 += x8 || x1;\r\n\r\n				npm = np1 > np2 ? np2 : np1;\r\n				g2 = npm >= 2 && npm <= 3;\r\n				g3 = (x1 && (x2 || x3 || !x8)) == 0;\r\n				g4 = (x5 && (x6 || x7 || !x4)) == 0;\r\n\r\n				if (g1&&g2&&g3) {\r\n					ucThinnedImage[iWidth*i + j] = 0;\r\n					++iDeletePoints;\r\n				}\r\n			}\r\n		}\r\n		memcpy(ucBinedImg,ucThinnedImage,iWidth*iHeight);\r\n		for (int i = 1; i < iHeight - 1;i++) {\r\n			pUp = ucBinedImg + (i - 1)*iWidth;\r\n			pImg = ucBinedImg + i * iWidth;\r\n			pDown = ucBinedImg + (i+1) * iWidth;\r\n			for (int j = 1; j < iWidth - 1; j++) {\r\n				pUp++;\r\n				pImg++;\r\n				pDown++;\r\n				if (!*pImg) {\r\n					continue;\r\n				}\r\n				x6 = *(pUp - 1);\r\n				x5 = *(pImg - 1);\r\n				x4 = *(pDown - 1);\r\n\r\n				x7 = *pUp;\r\n				xp = *pImg;\r\n				x3 = *pDown;\r\n\r\n				x8 = *(pUp + 1);\r\n				x1 = *(pImg + 1);\r\n				x2 = *(pDown + 1);\r\n\r\n				b1 = !x1 && (x2 == 1 || x3 == 1);\r\n				b2 = !x3 && (x4 == 1 || x5 == 1);\r\n				b3 = !x5 && (x6 == 1 || x7 == 1);\r\n				b4 = !x7 && (x8 == 1 || x1 == 1);\r\n\r\n				g1 = (b1 + b2 + b3 + b4) == 1;\r\n\r\n				np1 = x1 || x2;\r\n				np1 += x3 || x4;\r\n				np1 += x5 || x6;\r\n				np1 += x7 || x8;\r\n\r\n				np2 = x2 || x3;\r\n				np2 += x4 || x5;\r\n				np2 += x6 || x7;\r\n				np2 += x8 || x1;\r\n\r\n				npm = np1 > np2 ? np2 : np1;\r\n				g2 = npm >= 2 && npm <= 3;\r\n\r\n				g3 = (x1 && (x2 || x3 || !x8)) == 0;\r\n				g4 = (x5 && (x6 || x7 || !x4)) == 0;\r\n\r\n				if (g1&&g2&&g4) {\r\n					ucThinnedImage[iWidth*i+j] = 0;\r\n					++iDeletePoints;\r\n				}\r\n 			}\r\n		}\r\n\r\n		memcpy(ucBinedImg,ucThinnedImage,iWidth*iHeight);\r\n\r\n		if (iDeletePoints == 0) {\r\n			break;\r\n		}\r\n	}\r\n\r\n	for (int i = 0; i < iHeight; i++) {\r\n		for (int j = 0; j < iWidth; j++) {\r\n			if (i < 16) {\r\n				ucThinnedImage[i*iWidth + j] = 0;\r\n			}\r\n			else if (i >= iHeight - 16) {\r\n				ucThinnedImage[i*iWidth + j] = 0;\r\n			}\r\n			else if (j < 16) {\r\n				ucThinnedImage[i*iWidth + j] = 0;\r\n			}\r\n			else if (j >= iWidth - 16) {\r\n				ucThinnedImage[i*iWidth + j] = 0;\r\n			}\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n```\r\n![9](https://github.com/CasterWx/MFC-FingerPrint/raw/master/img/step9_Thinning.bmp)\r\n\r\n--------\r\n## 十.特征提取\r\n```c++\r\nint CutEdge(MINUTIAE* minutiaes,int count,unsigned char*ucImg,int iWidth,int iHeight) {\r\n	int minuCount = count;\r\n	int x, y, type;\r\n	bool del;\r\n	int *pFlag = new int[minuCount];\r\n	memset(pFlag,0,sizeof(int)*minuCount);\r\n	for (int i = 0; i < minuCount; i++) {\r\n		y = minutiaes[i].y - 1;\r\n		x = minutiaes[i].x - 1;\r\n		type = minutiaes[i].type ;\r\n		del = true;\r\n		if (x < iWidth / 2) {\r\n			if (abs(iWidth / 2 - x) > abs(iHeight / 2 - y)) {\r\n				while (--x >= 0) {\r\n					if (ucImg[x + y * iWidth] > 0) {\r\n						del = false;\r\n						break;\r\n					}\r\n				}\r\n			}\r\n			else {\r\n				if (y > iHeight / 2) {\r\n					while (++y < iHeight) {\r\n						if (ucImg[x + y * iWidth] > 0) {\r\n							del = false;\r\n							break;\r\n						}\r\n					}\r\n				}\r\n				else {\r\n					while (--y == 0) {\r\n						if (ucImg[x + y * iWidth] > 0) {\r\n							del = false;\r\n							break;\r\n						}\r\n					}\r\n				}\r\n			}\r\n		}\r\n		else {\r\n			if (abs(iWidth / 2 - x) > abs(iHeight / 2 - y)) {\r\n				while (++x < iWidth) {\r\n					if (ucImg[x + y * iWidth] > 0) {\r\n						del = false;\r\n						break;\r\n					}\r\n				}\r\n			}\r\n			else {\r\n				if (y > iHeight / 2) {\r\n					while (++y < iHeight) {\r\n						if (ucImg[x + y * iWidth] > 0) {\r\n							del = false;\r\n							break;\r\n						}\r\n					}\r\n				}\r\n				else {\r\n					while (--y >= 0) {\r\n						if (ucImg[x + y * iWidth] > 0) {\r\n							del = false;\r\n							break;\r\n						}\r\n					}\r\n				}\r\n			}\r\n		}\r\n		if (del) {\r\n			pFlag[i] = 1;\r\n			continue;\r\n		}\r\n	}\r\n	int newCount = 0;\r\n	for (int i = 0; i < minuCount; i++) {\r\n		if (pFlag[i] == 0) {\r\n			memcpy(&minutiaes[newCount],&minutiaes[i],sizeof(MINUTIAE));\r\n			newCount++;\r\n		}\r\n	}\r\n	delete[] pFlag;\r\n	pFlag = NULL;\r\n	return newCount;\r\n}\r\n```\r\n![10](https://github.com/CasterWx/MFC-FingerPrint/raw/master/img/step10_MinuExtract.bmp)\r\n\r\n--------\r\n## 十一.特征过滤\r\n```c++\r\nint MinuFilter(unsigned char *minuData,unsigned char *thinData,MINUTIAE *minutiaes,int &minuCount,int iWidth,int iHeight) {\r\n	float *dir = new float[iWidth*iHeight];\r\n	memset(dir,0,iWidth*iHeight*sizeof(float));\r\n	ImgDirection(thinData,dir,iWidth,iHeight);\r\n	unsigned char* pImg;\r\n	unsigned char val;\r\n	int temp = 0;\r\n	for (int i = 1; i < iHeight - 1; i++) {\r\n		pImg = minuData + i * iWidth;\r\n		for (int j = 1; j < iWidth - 1; j++) {\r\n			++pImg;\r\n			val = *pImg;\r\n			if(val>0){\r\n				minutiaes[temp].x = j + 1;\r\n				minutiaes[temp].y = i + 1;\r\n				minutiaes[temp].theta = dir[i*iWidth+j];\r\n				minutiaes[temp].type = int(val);\r\n				++temp;\r\n			}\r\n		}\r\n	}\r\n	delete[] dir;\r\n	minuCount = CutEdge(minutiaes,minuCount,thinData,iWidth,iHeight);\r\n	int *pFlag = new int[minuCount];\r\n	memset(pFlag,0,sizeof(int)*minuCount);\r\n	int x1, x2, y1, y2, type1, type2;\r\n	for (int i = 0; i < minuCount; i++) {\r\n		x1 = minutiaes[i].x;\r\n		y1 = minutiaes[i].y;\r\n		type1 = minutiaes[i].type;\r\n		for (int j = i + 1; j < minuCount; j++) {\r\n			if (pFlag[i] == 1) {\r\n				continue;\r\n			}\r\n			x2 = minutiaes[j].x;\r\n			y2 = minutiaes[j].y;\r\n			type2 = minutiaes[j].type;\r\n\r\n			int r = (int)sqrt(float((y1-y2)*(y1-y2)+(x1-x2)*(x1-x2)));\r\n\r\n			if (r <= 4) {\r\n				if (type1 == type2) {\r\n					if (type1 == 1) {\r\n						pFlag[i] = pFlag[j] = 1;\r\n					}\r\n					else {\r\n						pFlag[j] = 1;\r\n					}\r\n				}\r\n				else if (type1 == 1) {\r\n					pFlag[i] = 1;\r\n				}\r\n				else {\r\n					pFlag[j] = 1;\r\n				}\r\n			}\r\n		}\r\n\r\n	}\r\n	int newCount = 0;\r\n	for (int i = 0; i < minuCount; i++) {\r\n		if (pFlag[i] == 0) {\r\n			memcpy(&minutiaes[newCount],&minutiaes[i],sizeof(MINUTIAE));\r\n			newCount++;\r\n		}\r\n	}\r\n	delete[] pFlag;\r\n	minuCount = newCount;\r\n	return 0;\r\n}\r\n```\r\n![11](https://github.com/CasterWx/MFC-FingerPrint/raw/master/img/step11_MinuFilter.bmp)'),(3,'背叛爱情的人不配用我们介款软件','AntzUhl','/list/detail3.jsp','../images/cover/a31fd1ce73f56f7ab14e2882c016772e.png','2018-11-19',301,24,'人和人的互动，构成了我们身边这个异常复杂的世界。和平,纷争,茫然,矛盾,怀疑,真诚,争斗...面对这些,可能每个人都会觉得只有很小很小的一部分,可以自己搞定,绝大多数是完全无能为力的。','人工智能,生命','## 背叛爱情的人不配用我们介款软件\n\n#### 项目地址：[python-girlfriend-mood](https://github.com/CasterWx/python-girlfriend-mood)\n\n![a](https://github.com/CasterWx/python-girlfriend-mood/raw/master/CS.jpg?raw=true)\n\n博弈论是经济学领域一个非常重要的分支，博大精深,奥妙无穷。\n\n人和人的互动，构成了我们身边这个异常复杂的世界。和平,纷争,茫然,矛盾,怀疑,真诚,争斗...面对这些,可能每个人都会觉得只有很小很小的一部分,可以自己搞定,绝大多数是完全无能为力的。甚至有时候\n我们所付出的虔诚的努力,反而会让事物朝着反方向发展。而\"博弈论\",则给到我们一个全新的\"视角\",让我们从理性上审视应该如何与朋友,对手,亦敌亦友们\"和平相处\"。\n\n诺贝尔经济学奖得主马科维茨说过:\"多元化\"是应对不可预知风险的秘密武器。因此,博弈论不仅是一门经济学理论,更是一种多元化的思考方式。同时它也是一个\"游戏\",人生又何尝不是一场\"游戏\"呢？每个人都是宇宙Online里的角色。\n\n#### 与其茫然, 不如攻略技巧了解一下\n\n纳什均衡指的是博弈双方一种稳定的策略组合。\n在这种策略组合下，没有人能够通过单独改变策略占到更多便宜，所以这种组合是平衡、稳定的。\n \n这里我们再举一个经典的例子复习一下。\n \n 二战以后，世界格局变的相对明朗，其中最大的军事力量就是美国和苏联这两巨头。本来如果大家通力合作，共同发展，那说不定2018年人类早就飞出银河系了。\n \n \n可惜事与愿违。因为美国和苏联都在不断的烧钱搞军备竞赛——但无论是美国还是苏联，无论是官方还是民众，其实都从心底里不想再打仗了。既然如此，我们就忍一下对方的存在，不烧钱搞军备，老老实实省下钱来改善民生不行吗？\n \n这个真不行。\n\n![b](https://images2018.cnblogs.com/blog/1291955/201806/1291955-20180615101554137-193737876.png)\n\n从纳什均衡来看，这个世界或许并不存在真正意义上的“和平共处，其乐融融”。看似平静安详的背后是无数的相互制衡，这些制衡构成了我们所说的“和平”。所以说，构建“和平”的方式并不在于“宣扬和平的诉求”，而是构建“没有人愿意单方面打破和平”的状态。\n\n在我们初步理解了纳什均衡的思考方式：理解对手的观点，并推断TA会如何回应你的行为。\n \n \n那么我们再看一个栗子。 耶鲁大学的著名经济学教授马丁·舒彼克（Martin Shubik）曾设计过这样一个实验：让学生们为1美元竞拍出价。\n出价最高的人可以用他报出来的价格换取这1美元。而出价次高的人就比较惨了，他不仅拿不到奖励，还得赔上自己报出来的价格。\n \n如果你参加了这个博弈，你会出多少钱？\n\n我们再回忆一下纳什均衡的精髓：<font color=\"red\">没有人能够通过单独改变策略占到更多便宜。</font>\n\n所以我出价20美分，那别人就会出30美分；我出60美分，别人就会出70美分。算来算去，只有大家都出100美分，也就是1美元，才能达到纳什均衡。\n\n当然了，这个均衡有个先决条件，那就是平局的情况下大家都不用赔钱。这样一来，我出100美分，你也出100美分，没人能够通过单独改变策略而占到便宜。\n\n那么……如果不允许平局呢？假设平局时大家必须赔上自己的报价，那么纳什均衡会是什么样呢？\n\n\n####  其实大家都知道，信息是公开互等的，她了解他的同时，她也在了解你，你很难在决策上完全压制她。除非……除非你变成疯子。\n\n再来看看介款程序 python-girlfriend-mood\n\n信息的公开,再你了解她的同时,她也在了解你，那么如何决策就是一件非常重要的事了。\n\n通过对一句话的分析，可以提取出相应的关键词，关键词的数量决定了这句话的情感复杂程度,香农老祖可以解释这一点。\n\n假如说我要\"完全\"销毁两篇日记,一篇中是我平常的生活日志,另一篇中是一群类似于东方咒语的神秘符号。\n\n那么\"完全\"销毁这两篇日记的代价分别又是多少呢？\n\n对于一篇简单的生活日记，我们只需要销毁日志中出现的我的相关信息,可能是我使用过的电脑,我交流过的人等等。虽然麻烦,但是只要一步步销毁下去，对于这篇日记以及日记中我的举动的存在就可以完全不被知道。(最后一步是销毁我自己)\n\n对于这篇\"东方咒语\"的销毁难度会有多大呢？只能说，对于每一个符号，我们都需要分析含义，然后进行分解，又说不定其中有哪些神秘的含义，代表着宇宙的终极奥义呢。\n\n#### 所以销毁一个物体的难度是由物体的信息复杂程度来决定的。\n\n同理我们也可以结合香农熵的公式，以及开头的玄学公式，得到所谓的情感值。\n\n#### 关键点 ： 关键词 情感词 情感值\n\n##### 关键词提取参考 : [分词方法](https://github.com/CasterWx/python-girlfriend-mood/blob/master/README.md)\n\n##### 情感词分析方法 :  词库,在项目中的目前词库数量 [词库](https://github.com/CasterWx/python-girlfriend-mood/tree/master/data)\n\n##### 情感值分析方法 :  在给定初始基值的情况下,输入一句话,先进行分词，再获得关键词,再根据词库获取其中的情感词汇,可以看到词库中的大多词汇都拥有前人根据经验给出的情感值,所以...可以先使用这些数据,进行简单的计算。\n\n\n当然，这种情感的计算有很大很大的误差,比如现在社会上的一些直男标语,多喝热水什么的，很难在没有大规模词库的情况下分析出这是负情感值。\n\n词库以及情感词计算公式的完善可能需要你们的支持了!!!\n'),(4,'完善堆栈内存管理','HHw','/list/detail4.jsp','../images/cover/6d571ba2675a299e32c310629f015ccb.png','2018-11-27',625,34,'\nmalloc函数用于程序运行时动态从堆中申请内存,但malloc仅仅是堆内存接口,能够动态分配内存,底层必然有一套完善的内存管理系统在支撑。因此实现malloc的前提是先把底层系统搭建起来。','c++,OS','# <b>完善堆栈内存管理</b>\r\n\r\nmalloc函数用于程序运行时动态从堆中申请内存,但malloc仅仅是堆内存接口,能够动态分配内存,底层必然有一套完善的内存管理系统在支撑。因此实现malloc的前提是先把底层系统搭建起来。\r\n\r\n## malloc底层原理\r\n\r\n系统分配的内存都是以4Kb大小的页框为单位的，当我们仅需要几十字节,几百字节这样的小内存块时,显然无法直接满足,为此必须实现一种小内存块的管理,可以满足任意内存大小的分配,这就是malloc的任务。\r\n\r\narena是很多开源项目都会使用到的内存管理概念,将一大块内存划分为多个小内存块,每个小内存块之间互不干扰,可以分别管理,这些小内存块就称为arena。\r\n\r\narena是由一大块内存划分成无数小内存块的内存仓库,系统只能分配4Kb粒度的内存页框的情况下,arena的一大块内存就是申请到的4Kb粒度大小的内存,根据请求的内存量大小,arena的大小也许是一个页框,也许是多个页框,随后再将它们平均拆分为多个小内存块。至于小内存块应该多大,可以有多种不同的规格大小,那就有多种不同规格的arena,比如一种arena中全是16字节大小的内存块,故它只响应16字节以内的内存分配,另一种arena中全是32字节大小的内存块,故它只响应32字节以内的内存分配。我们平时使用的malloc申请内存时,操作系统返回的地址其实就是某个内存块的起始地址,操作系统会根据malloc申请内存的大小来选择不同规格的内存块。因此为支持多种容量内存块的分配,我们需要建立多种不同容量内存块的arena。\r\n\r\narena是个提供内存分配的数据结构,它分为两部分,一部分是元信息,用来描述自己内存池中空闲内存块的数量,其中包括内存块描述符指针,通过它可以间接获知本arena所包含内存块的规格大小,此部分占用空间是固定的,约12字节。另一部分就是内存池区域,这里面有无数的内存块,此部分占用大量的arena空间。整个arena就像一个仓库,元信息就像库房管理员,内存块相当于库物品。\r\n\r\n内存块描述符中有block_size为规格大小,还有free_list队列来指向这一规格还空闲可用的arena汇总,所以在分配时必须进过此处free_list挑选,最终所分配的内存块必定属于free_list队列中的某个arena。\r\n\r\n尽管arena用小内存块来满足小内存量的分配,但实际上,arena为内存分配提供了统一的入口,无论申请的内存量是多大,都可以用同一个arena来分配内存。小内存块的容量虽然有几种规格,但毕竟是为了满足小内存量的分配,最大内存块容量不会超过1024字节,如果申请的内存量较大,超过1024字节,单独的一个小内存块无法满足时,就需要将多个较大的小内存块组合,但这样却极大的影响了性能,所以对于大内存请求时也会创建一个arena,但不会再拆分,而是将它直接分配出去,此类arena没用对应的内存块描述符,元信息中内存块描述符指针为空。\r\n\r\n总结,在内存管理中,arena为任意大小内存的分配提供了统一接口,它既支持1024字节以下的小块内存分配,又支持大于1024字节以上的大块内存,malloc实际上就是通过arena申请这些内存块。arena是个内存仓库,并不是直接对外提供内存分配,只有内存块描述符才对外提供内存块,内存块描述符将同类arena中空闲的内存块汇聚到一起,作为某一规格内存块的分配入口。\r\n\r\n## 底层初始化\r\n\r\nmemory.h\r\n```\r\n#define DESC_CNT 7   // 内存块描述符种类个数  16/32/64/128/256/512/1024字节\r\n\r\n/* 内存块描述符 */\r\nstruct memory_block_desc {\r\n   int block_size;		 // 内存块大小\r\n   int blocks_number;	 // arena中可容纳此memory_block的数量.\r\n   struct list free_block;	 // 目前可用的memory_block链表\r\n};\r\n\r\n/* 内存块 */\r\nstruct memory_block {\r\n   struct list free_block;\r\n};\r\n```\r\n\r\nmemory.c\r\n```\r\n/* 内存仓库arena元信息 */\r\nstruct arena {\r\n   struct memory_block_desc* desc;	 // 此arena关联的memory_block_desc\r\n   int cnt;\r\n   bool large;  // true:申请超过1024字节,cnt为页框数; false:不过1024,cnt表示空闲memory_block数量\r\n};\r\n\r\n/* 为malloc做准备 */\r\nvoid block_desc_init(struct memory_block_desc* desc_array) {\r\n   int desc_idx, block_size = 16;\r\n\r\n   /* 初始化每个memory_block_desc描述符 */\r\n   for (desc_idx = 0; desc_idx < DESC_CNT; desc_idx++) {\r\n      desc_array[desc_idx].block_size = block_size;\r\n\r\n      /* 初始化arena中的内存块数量 */\r\n      desc_array[desc_idx].blocks_per_arena = (PG_SIZE - sizeof(struct arena)) / block_size;\r\n\r\n      list_init(&desc_array[desc_idx].free_list);\r\n\r\n      block_size *= 2;         // 更新为下一个规格内存块\r\n   }\r\n}\r\n\r\n/* 内存管理部分初始化入口 */\r\nvoid memory_init() {\r\n   put_str(\"mem_init start\\n\");\r\n   unsigned int mem_bytes_total = (*(uint32_t*)(0xb00));\r\n   mem_pool_init(mem_bytes_total);	  // 初始化内存池\r\n/* 初始化mem_block_desc数组descs,为malloc做准备 */\r\n   block_desc_init(k_block_descs);\r\n   put_str(\"mem_init done\\n\");\r\n}\r\n\r\n```\r\n'),(5,'技术宅也要谈恋爱之早安晚安自动化','AntzUhl','/list/detail5.jsp','../images/cover/header-mai.jpg','2018-11-30',424,15,'发小一直很喜欢说早安晚安（当然是我说给她），但我经常会忘记，最近灵机一动，想出来这样一个科学高效方便快捷稳定地说早安晚安的办法：\r\n\r\n把微信挂在服务器上，每天固定时间，自动执行发送早晚安文本消息的命令！','Python','### 发小一直很喜欢说早安晚安（当然是我说给她），但我经常会忘记，最近灵机一动，想出来这样一个科学高效方便快捷稳定地说早安晚安的办法：\r\n\r\n### 把微信挂在服务器上，每天固定时间，自动执行发送早晚安文本消息的命令！\r\n\r\n### 代码很简单，放在了 GitHub 上，具体效果是每天早上 9 点半发一个 “早安”，然后晚上 12 点再发一个 “晚安”。\r\n\r\n### 太好了！以后再也不会忘记说早安晚安了！开心！\r\n\r\n![ds](https://diygod.me/images/havefun.jpg)\r\n\r\n### 脚本已经部署到服务器上了，明天早上给发小一个惊喜！\r\n\r\n### 实际使用的效果明天会更新到下面（肯定没问题，稳得很！）：'),(6,'肥宅也要谈恋爱之女朋友情绪分析','HHw','/list/detail6.jsp','../images/cover/736587c304df9f80e933259fa94fc7cc.png','2018-11-27',625,34,'一款为单身狗定制的软件.代码写好了，就差个女朋友了。','Python,数据分析,jieba','## 通过对话分析女朋友的情绪值波动\n\n> Blog : [Antzuhl](http://www.cnblogs.com/LexMoon/)\n\n> Github : [CasterWx](https://github.com/CasterWx)\n\n> 扩展小猫粮 : [小猫粮](https://github.com/CasterWx/python-girlfriend-mood/blob/master/Other.md)\n\n![todo](https://github.com/CasterWx/python-girlfriend-mood/blob/master/CS.jpg?raw=true)\n\n:kissing_closed_eyes::kissing_closed_eyes:  通过女朋友的一句话分析她的心情 。\n\nAnalyze her mood through her girlfriend\'s words .\n\n\n## 第一章 分词\n\n### 1、JieBa库\n>“结巴”中文分词：做最好的 Python 中文分词组件\n\n>\"Jieba\" (Chinese for \"to stutter\") Chinese text segmentation: built to be the best Python Chinese word segmentation module.\n\n### 2、特点\n * 支持三种分词模式：\n     * 精确模式，试图将句子最精确地切开，适合文本分析；\n     * 全模式，把句子中所有的可以成词的词语都扫描出来, 速度非常快，但是不能解决歧义；\n     * 搜索引擎模式，在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。\n\n * 支持繁体分词\n * 支持自定义词典\n * MIT 授权协议\n\n### 3、算法\n * 基于前缀词典实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图 (DAG)\n * 采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合\n * 对于未登录词，采用了基于汉字成词能力的 HMM 模型，使用了 Viterbi 算法\n\n### 4、主要功能\n\n####   1) 分词\n * `jieba.cut` 方法接受三个输入参数: 需要分词的字符串；cut_all 参数用来控制是否采用全模式；HMM 参数用来控制是否使用 HMM 模型\n * `jieba.cut_for_search` 方法接受两个参数：需要分词的字符串；是否使用 HMM 模型。该方法适合用于搜索引擎构建倒排索引的分词，粒度比较细\n * 待分词的字符串可以是 unicode 或 UTF-8 字符串、GBK 字符串。注意：不建议直接输入 GBK 字符串，可能无法预料地错误解码成 UTF-8\n * `jieba.cut` 以及 `jieba.cut_for_search` 返回的结构都是一个可迭代的 generator，可以使用 for 循环来获得分词后得到的每一个词语(unicode)，或者用\n * `jieba.lcut` 以及 `jieba.lcut_for_search` 直接返回 list\n * `jieba.Tokenizer(dictionary=DEFAULT_DICT)` 新建自定义分词器，可用于同时使用不同词典。`jieba.dt` 为默认分词器，所有全局分词相关函数都是该分词器的映射。\n```python\nseg_list = jieba.cut(\"我要有女朋友了\", cut_all=True)\nprint(\"全模式: \" + \"/ \".join(seg_list))  # 全模式\n\nseg_list = jieba.cut(\"我要有女朋友了\", cut_all=False)\nprint(\"默认模式: \" + \"/ \".join(seg_list))  # 默认模式\n\nseg_list = jieba.cut(\"我要有女朋友了\")\nprint(\", \".join(seg_list))\n\nseg_list = jieba.cut_for_search(\"我要有女朋友了，然后我要打爆室友的狗头\")  # 搜索引擎模式\nprint(\"搜索引擎模式: \"+\", \".join(seg_list))  \n```\noutput :\n```\n全模式: 我/ 要/ 有/ 女朋友/ 朋友/ 了\n默认模式: 我要/ 有/ 女朋友/ 了\n我要, 有, 女朋友, 了\n搜索引擎模式: 我要, 有, 朋友, 女朋友, 了, ，, 然后, 我要, 打爆, 室友, 的, 狗头\n```\n####   2) 添加自定义词典\n >载入词典\n * 开发者可以指定自己自定义的词典，以便包含 jieba 词库里没有的词。虽然 jieba 有新词识别能力，但是自行添加新词可以保证更高的正确率\n * 用法： jieba.load_userdict(file_name) # file_name 为文件类对象或自定义词典的路径\n * 词典格式和 `dict.txt` 一样，一个词占一行；每一行分三部分：词语、词频（可省略）、词性（可省略），用空格隔开，顺序不可颠倒。`file_name` 若为路径或二进制方式打开的文件，则文件必须为 UTF-8 编码。\n * 词频省略时使用自动计算的能保证分出该词的词频。\n```python\nprint(\'/\'.join(jieba.cut(\'这个东梨会不会被分开呢。\', HMM=False)))\n# 添加字典\nprint(jieba.suggest_freq((\'东梨\'), True)) # 添加一个词语\'东梨\'\nprint(\'/\'.join(jieba.cut(\'这个东梨会不会被分开呢。\', HMM=False)))\n```\noutput :\n```\n这个/东/梨/会/不会/被/分开/呢/。\n这个/东梨/会/不会/被/分开/呢/。\n```\n\n >调整词典\n\n* 使用 `add_word(word, freq=None, tag=None)` 和 `del_word(word)` 可在程序中动态修改词典。\n* 使用 `suggest_freq(segment, tune=True)` 可调节单个词语的词频，使其能（或不能）被分出来。\n\n* 注意：自动计算的词频在使用 HMM 新词发现功能时可能无效。\n\n####   3) 关键词提取\n> 基于 TF-IDF 算法的关键词抽取\n\n`import jieba.analyse`\n\n* jieba.analyse.extract_tags(sentence, topK=20, withWeight=False, allowPOS=())\n  * sentence 为待提取的文本\n  * topK 为返回几个 TF/IDF 权重最大的关键词，默认值为 20\n  * withWeight 为是否一并返回关键词权重值，默认值为 False\n  * allowPOS 仅包括指定词性的词，默认值为空，即不筛选\n* jieba.analyse.TFIDF(idf_path=None) 新建 TFIDF 实例，idf_path 为 IDF 频率文件\n\n```python\ns = \"操作系统（Operation System，简称OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石；操作系统本质上是运行在计算机上的软件程序 ；为用户提供一个与系统交互的操作界面 ；操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。\"\nfor x, w in jieba.analyse.extract_tags(s, withWeight=True):\n    print(\'%s %s\' % (x, w))\n\nprint(\'-\'*40)\nprint(\' TextRank\')\nprint(\'-\'*40)\n\nfor x, w in jieba.analyse.textrank(s, withWeight=True):\n    print(\'%s %s\' % (x, w))\n```\noutput :\n```\n内核 1.0625279118105262\n操作系统 0.7315222629276317\n外壳 0.4645002019336842\n软件程序 0.36580730663157895\n软件资源 0.34756659135263157\n程序 0.3333060550794737\n操作界面 0.32345367735526315\nOperation 0.31459914481315787\nSystem 0.31459914481315787\nOS 0.31459914481315787\n计算机硬件 0.2800679240526316\n应用程序 0.2763021123763158\n计算机系统 0.23982068182078944\n交互 0.23731251919447366\n基石 0.23595272944342105\n硬件 0.22168984473789474\n本质 0.18271527055526315\n用户 0.1795351598005263\n计算机 0.1790732744968421\n围绕 0.177282393885\n----------------------------------------\n TextRank\n----------------------------------------\n内核 1.0\n程序 0.5362199524590612\n系统 0.48948949335129555\n提供 0.48602227553244165\n围绕 0.4446670737747918\n运行 0.4225011310851474\n管理 0.4151898395341863\n基石 0.4131936048253403\n计算机系统 0.38302557644090945\n硬件 0.36775003601316436\n操作 0.36615155530109056\n本质 0.3554627436547271\n计算机硬件 0.3491604047032015\n理解 0.3433887505596043\n外壳 0.3419635842574655\n应用程序 0.33616306371021853\n用户 0.33122514947879544\n交互 0.3287196036788538\n计算机 0.23122054865622482\n简称 0.22777433887730136\n```\n####   4) 词性标注\n* `jieba.posseg.POSTokenizer(tokenizer=None)` 新建自定义分词器，`tokenizer` 参数可指定内部使用的 `jieba.Tokenizer` 分词器。`jieba.posseg.dt` 为默认词性标注分词器。\n* 标注句子分词后每个词的词性，采用和 ictclas 兼容的标记法。\n* 用法示例\n```python\nwords = jieba.posseg.cut(\"我爱北京天安门\")\nfor word, flag in words:\n    print(\'%s %s\' % (word, flag))\nprint(\'=\'*40)\n```\noutput :\n```\n我 r\n爱 v\n北京 ns\n天安门 ns\n```\n####   5) 并行分词\n* 原理：将目标文本按行分隔后，把各行文本分配到多个 Python 进程并行分词，然后归并结果，从而获得分词速度的可观提升\n* 基于 python 自带的 multiprocessing 模块，目前暂不支持 Windows\n* 用法：\n    * `jieba.enable_parallel(4)` # 开启并行分词模式，参数为并行进程数\n    * `jieba.disable_parallel()` # 关闭并行分词模式\n\n####   6) Tokenize：返回词语在原文的起止位置\n* 注意，输入参数只接受 unicode\n* 默认模式\n```python\nprint(\' 默认模式\')\nprint(\'-\'*40)\nresult = jieba.tokenize(\'永和服装饰品有限公司\')\nfor tk in result:\n    print(\"word %s\\t\\t start: %d \\t\\t end:%d\" % (tk[0],tk[1],tk[2]))\n\nprint(\'-\'*40)\nprint(\' 搜索模式\')\nprint(\'-\'*40)\n\nresult = jieba.tokenize(\'永和服装饰品有限公司\', mode=\'search\')\nfor tk in result:\n    print(\"word %s\\t\\t start: %d \\t\\t end:%d\" % (tk[0],tk[1],tk[2]))\n```\noutput :\n```\nword 永和		 start: 0 		 end:2\nword 服装		 start: 2 		 end:4\nword 饰品		 start: 4 		 end:6\nword 有限公司		 start: 6 		 end:10\n----------------------------------------\n 搜索模式\n----------------------------------------\nword 永和		 start: 0 		 end:2\nword 服装		 start: 2 		 end:4\nword 饰品		 start: 4 		 end:6\nword 有限		 start: 6 		 end:8\nword 公司		 start: 8 		 end:10\nword 有限公司		 start: 6 		 end:10\n```\n\n### 5、一个完整的分词可运行实例\n目录结构\n> jieba是我们要导入的第三方库，在项目中我直接把它放在了里面。\n\n\nrun.py中编写代码，并且调用jieba库实现分词。\n\nrun.py\n```python\n#encoding=utf-8\nfrom __future__ import unicode_literals\nimport jieba\n\nif __name__==\"__main__\":\n    ch = input()\n    seg_list = jieba.cut(str(ch))\n    print(\", \".join(seg_list))\n```\n在此处输入\"我马上就要有女朋友了\"。\n\n即可得到输出结果如下。\n> 我, 马上, 就要, 有, 女朋友, 了\n\n### 6、代码地址\n    Github : [https://github.com/CasterWx/python-girlfriend-mood](https://github.com/CasterWx/python-girlfriend-mood)\n');
/*!40000 ALTER TABLE `t_blog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_comment`
--

DROP TABLE IF EXISTS `t_comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `url` varchar(255) DEFAULT NULL,
  `imgurl` varchar(255) DEFAULT NULL,
  `time` varchar(255) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  `content` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_comment`
--

LOCK TABLES `t_comment` WRITE;
/*!40000 ALTER TABLE `t_comment` DISABLE KEYS */;
INSERT INTO `t_comment` VALUES (1,'/list/detail0.jsp','../images/Absolutely.jpg','2018-11-30 19:17:21','AntzUhl','博主有女朋友嘛!'),(2,'/list/detail0.jsp','../images/Absolutely.jpg','2018-11-30 23:27:54','CasterWx','我是弹幕王者!'),(3,'/list/detail1.jsp','../images/Absolutely.jpg','2018-11-30 23:27:54','CasterWx','这是在第一个里面'),(4,'/list/detail2.jsp','../images/Absolutely.jpg','2018-11-30 23:27:54','AntzUhl','这是在第二个里面'),(9,'/list/detail0.jsp','../images/Absolutely.jpg','2018-11-30 23:27:54','游客','妈耶~'),(10,'/list/detail1.jsp','../images/Absolutely.jpg','2018-11-30 23:28:41','游客','第二个游客！');
/*!40000 ALTER TABLE `t_comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_log`
--

DROP TABLE IF EXISTS `t_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_log` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `time` varchar(255) DEFAULT NULL,
  `title` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_log`
--

LOCK TABLES `t_log` WRITE;
/*!40000 ALTER TABLE `t_log` DISABLE KEYS */;
INSERT INTO `t_log` VALUES (1,'2018年12月1日','添加音乐列表'),(2,'2018年11月30日','博客迁移上线！'),(3,'2018年11月29日','添加视频弹幕姬'),(4,'2018年11月21日','python-grilfriend-mood达到100star'),(5,'2018年11月14日','狂三耳机到货'),(6,'2018年10月15日','收到薇尔丽特手办!'),(7,'2018年10月1日','开始国庆节假期!'),(8,'2018年9月29日','想买darling官方画师画本, 质量超级棒，舔爆！\n\n如果给我一次机会，我应该会买三本，一本自舔一本收藏一本传教'),(9,'2018年9月27日','相信没人做开源项目是为了赚钱，因为它还不如去天桥贴膜赚得快。'),(10,'2018年9月23日','救命啊，我被撩到了！\r\n没错，我就是她的 Darling！'),(11,'2018年9月17日','音乐，人类生活中永恒的主题。'),(12,'2018年9月10日','新的开始，只做了一点微小的改动'),(13,'2018年9月1日','开学上课！！！'),(14,'2018年8月21日','精神痛苦+身体痛苦 等于 双重痛苦 . ');
/*!40000 ALTER TABLE `t_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_music`
--

DROP TABLE IF EXISTS `t_music`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_music` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `artist` varchar(255) DEFAULT NULL,
  `lrc` varchar(255) DEFAULT NULL,
  `theme` varchar(255) DEFAULT NULL,
  `url` varchar(255) DEFAULT NULL,
  `cover` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_music`
--

LOCK TABLES `t_music` WRITE;
/*!40000 ALTER TABLE `t_music` DISABLE KEYS */;
INSERT INTO `t_music` VALUES (1,'カサネテク','中关村二','../aplayer/darling.lrc','#ebd0c2','../aplayer/music.mp3','http://p2.music.126.net/AWXPd_GVXCzUocAMyatE5Q==/760862046442975.jpg?param=130y130'),(2,'不醉不会','田馥甄','https://api.i-meto.com/api/v1/meting?server=netease&type=lrc&id=28018072&auth=ce08141601ab1b10a41060a92bd72a093c9945c1677ab9cc7318ee22ce5042b4','#ebd0c2','https://api.i-meto.com/api/v1/meting?server=netease&type=url&id=28018072&auth=416122fb72a2de809df106a9fd066ecfc87790083395b291a683c26633be506f','https://api.i-meto.com/api/v1/meting?server=netease&type=pic&id=109951163571315498&auth=d170f27a04094b4aed5c82e8a6139871528b0138918dbcd3c1c93a2721597d60'),(3,'君のせい','the peggies','https://api.i-meto.com/api/v1/meting?server=netease&type=lrc&id=1313107902&auth=69ac3664a352b0edc4a69cb2becc6763e479090bdad615f71132f5970a72c382','#ebd0c2','https://api.i-meto.com/api/v1/meting?server=netease&type=url&id=1313107902&auth=f8189e443120762c7f332dfc4a25d7480e3746e63bf6960875a41b16662b52a2','https://api.i-meto.com/api/v1/meting?server=netease&type=pic&id=109951163584774774&auth=e39794915dfc23dec72fc58c1b9516149819efaf50ec568e8072ee8ea30b0632'),(4,'达拉崩吧（Cover 洛天依&言和）','三无MarBlue','https://api.i-meto.com/api/v1/meting?server=netease&type=lrc&id=476114873&auth=8fbf2662e9210a5cd5be15bd5dd0b757d6ca8c7dda19ff9e58aa394ec75eef4d','#ebd0c2','https://api.i-meto.com/api/v1/meting?server=netease&type=url&id=476114873&auth=7033954f7e5af50528ecc8f4a56d1aae68696190711d64764bcd9b591f9e5240','https://api.i-meto.com/api/v1/meting?server=netease&type=pic&id=109951162920302240&auth=5d4a1cdafaf41bc06afa1a7e2822e3298fd245df3b70f37924ab512d5bd693e6'),(5,'大小姐和大少爷的反派生涯（Cover 洛天依）','漆柚 / 凯玟桑','https://api.i-meto.com/api/v1/meting?server=netease&type=lrc&id=515649515&auth=2f5c49fbafdc01933f34ed7dd138cba477144482de546bcc074fce4a3814213f','#ebd0c2','https://api.i-meto.com/api/v1/meting?server=netease&type=url&id=515649515&auth=22331e6684cbfa3b5bcea930df4e0de4f4ec93c4ac547adbd2e8984397fb28fc','https://api.i-meto.com/api/v1/meting?server=netease&type=pic&id=109951163051228672&auth=747a9d9ef58e8b40cc5b906d4274490f753e99bca00a9ddc23a8f9fc82f7a7e6'),(6,'女孩你为何踮脚尖（Cover 洛天依 / 双笙）','Akie秋绘','https://api.i-meto.com/api/v1/meting?server=netease&type=lrc&id=511759501&auth=fae2fa6ac2d6682e43ccf76ee3d13fd967ba04dbe8eb16062f40d69a40340465','#ebd0c2','https://api.i-meto.com/api/v1/meting?server=netease&type=url&id=511759501&auth=327a1cea8d6b0256a84c0ad51bd8b70ec78f0a72b625d04c8d88a2c6f10721b4','https://api.i-meto.com/api/v1/meting?server=netease&type=pic&id=109951163039238417&auth=bd2816b9fce37471f5459f25d75e17aa22dfd081903e884a61719e6507f902cd'),(7,'权御天下（Cover 洛天依）','三无MarBlue','https://api.i-meto.com/api/v1/meting?server=netease&type=lrc&id=445816167&auth=9c4b1aca3d737c789e4bd89010e03766958a19dc4ad2e4c1669d31bd4e7b31e6','#ebd0c2','https://api.i-meto.com/api/v1/meting?server=netease&type=url&id=445816167&auth=c7b261e43429a90fb2b638a8f29c8edb361bcb96730889f0c7bb05a7f7e249f1','https://api.i-meto.com/api/v1/meting?server=netease&type=pic&id=109951162920302240&auth=5d4a1cdafaf41bc06afa1a7e2822e3298fd245df3b70f37924ab512d5bd693e6'),(8,'匆匆那年','王菲','https://api.i-meto.com/api/v1/meting?server=netease&type=lrc&id=29713754&auth=78b1d5fea1dacfe7becf63a2edeefc16e56731836fba012bad11d26434848a01','#ebd0c2','https://api.i-meto.com/api/v1/meting?server=netease&type=url&id=29713754&auth=143a86f5d53655ae76a1d926be9721ce4c94465c561b2bda0c105a5db0fe7bf8','https://api.i-meto.com/api/v1/meting?server=netease&type=pic&id=2542070884980240&auth=ad1eea2f4228a4ca61873978594ea79dc7ebac7497be81b38e49fa762c658c6c'),(9,'神的随波逐流','泠鸢yousa','https://api.i-meto.com/api/v1/meting?server=netease&type=lrc&id=29753702&auth=9d138e31faf1979295062b45eadded99b63e8ad6876d9f586ec0cf3bea9e9e51','#ebd0c2','https://api.i-meto.com/api/v1/meting?server=netease&type=url&id=29753702&auth=71b37f5118395b9766c57cc978788879cb5b67395a2fdea37146b19c08e147e5','https://api.i-meto.com/api/v1/meting?server=netease&type=pic&id=3415083117091734&auth=0ca93527298443cfb19be2cba151835bdbaf05aa22f75e1b6e15a1db79d9bbd9');
/*!40000 ALTER TABLE `t_music` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_user`
--

DROP TABLE IF EXISTS `t_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `t_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `isroot` bit(1) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_user`
--

LOCK TABLES `t_user` WRITE;
/*!40000 ALTER TABLE `t_user` DISABLE KEYS */;
/*!40000 ALTER TABLE `t_user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2018-12-02 13:43:42
